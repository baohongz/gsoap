#'
#' More description
#'
#' @param x a data frame with the results of gene set over-representation analysis.
#' Must have a rownames indicating names of the genes sets and at least two columns,
#' one of which contains query gene members; and another one that contains respective
#' p-values (raw or adjusted for multiple testing).
#'
#' @param genes a character or integer, indicating name or index of the column containing genes members.
#' @param pvalues a character or integer, indicating name or index of the column containing p-values.
#' @param splitter a character to be used as a delimiter to parse the genes column.
#' @param distance a character indicating method used to calculate the distance/dissimilarity between instances.
#' Options include (but are not limited to) \emph{jaccard} (default), \emph{manhattan}, \emph{dice},
#' \emph{pearson}. For more details see \code{\link[philentropy]{distance}}.
#' @param projection a character indicating method used to project instances into 2-dimensional space based on their distance/dissimilarity..
#' Ooptions include \emph{iso} (isomap; default), \emph{mds} (multidimensional scaling), \emph{cca} (curvilinear component analysis), \emph{tsne} (t-distributed stochastic neighbor embedding),
#' @param scale.factor a positive real number to control dependence of the circle radius on the number of query gene members of the given gene set.
#' @param weighted a boolean indicating whether to use weights when centrality and clustering are calculated.
#' @param log10.weights a boolean indicating whether weights should undergo
#' additional log10 tranformation
#' @param packing a boolean indicating whether to apply circle packing.
#' @param isomap.k an integer indicating number of k nearest neighbors of
#' the \emph{isomap} projection.
#' @param tsne.perplexity an integer indicating \emph{tSNE} perplexity.
#' @param tsne.iterations an integer indicating maximum number of \emph{tSNE} iterations to perform.
#' @param cca.epochs an integer indicating \emph{CCA} training length.
#' @param clustering a boolean indicating whether to apply clustering.
#' @param hc.method a character indicating method of hierarchical cluster to be used.
#' Options include: \emph{ward.D} (default), \emph{ward.D2}, \emph{single}, \emph{complete},
#' \emph{average}, \emph{mcquitty}, \emph{median} and \emph{centroid}.
#' @param no.clusters an integer indicating number of clusters, must be less than number of gene sets (rows).
#' @param max.clusters an integer indicating maximum number of clusters to consider, must be at least two.
#' @param cluster.stat an indicating statistic used to select optimal number of clusters.
#' Options are:
#' \itemize{
#'     \item \emph{meta} (default) is a combination of the methods listed below
#'     \item \emph{PBC} (point biserial correlation; default)
#'     \item \emph{HG} (Hubert's samma)
#'     \item \emph{HGSD} (Hubert’s samma - Somer's D)
#'     \item \emph{ASW} (average silhouette width)
#'     \item \emph{ASWw} (Average weighted silhouette width)
#'     \item \emph{CH} (Calinski-Harabasz index)
#'     \item \emph{R2} (R-squared)
#'     \item \emph{CHsq} (Calinski-Harabasz index using squared distances)
#'     \item \emph{R2sq} (R-squared using squared distances)
#'     \item \emph{HC} (Hubert’s C coefficient)
#' }
#' @param pam.boots a positive integer indicating number of boostraps used to be used when selecting number of clusters.
#'
#' @return A \code{gsoap} object that is a list comprising following components
#' \itemize{
#'     \item \code{layout} data frame with x and y coordinates of
#'     the points representing the insttances, their size (radius) derived from
#'     the number of gene members; weight (-log10(p-value)), centrality
#'     and cluster membership.
#'     \item \code{stress} Kruskall stress caused by projection and circle packing.
#'     \item \code{spcorr} Spearman correlation between the original distances/dissimilarities
#'     between gene sets and those obtained after projection and circle packing.
#' }
#'
#' @author Tomas Tokar <tomastokar@gmail.com>
#'
#' @examples
#' data(pxgenes)
#'
#' l = gsoap_layout(pxgenes, 'Members', 'p.value')
#'
#' head(l$layout)
gsoap_layout = function(x,
genes,
pvalues,
splitter = '/',
distance = 'jaccard',
projection = 'iso',
scale.factor = 1.0,
weighted = TRUE,
packing = TRUE,
clustering = TRUE,
hc.method = 'ward.D',
isomap.k = 3,
tsne.perplexity = 30,
tsne.iterations = 1e+3,
cca.epochs = 10,
cca.alpha0 = 0.5,
no.clusters = NULL,
max.clusters = 8,
cluster.stat = 'meta'){
# -------------
# Check inputs
# -------------
if (missing(x)){
stop('Input is missing')
}
if (!is.data.frame(x)){
stop('Input is not data frame')
}
if (!is.character(rownames(x))){
stop('Input has missing or improper rownames')
}
if(!((genes %in% colnames(x))|(genes %in% 1:ncol(x)))){
stop('Wrong `genes` value')
}
if(!((pvalues %in% colnames(x))|(pvalues %in% 1:ncol(x)))){
stop('Wrong `pvalues` value')
}
if (!any(grepl(splitter, x[,genes]))){
warning('Either `genes`, or `splitter` seem to be not correct.')
}
# --------------
# Create layout
# --------------
# Extract query genes -- instances memberships
memberships.list = setNames(strsplit(x[,genes], splitter), rownames(x))
# Create association matrix
asc.mat = create_association_matrix(memberships.list)
# Get number of member genes
no.members = rowSums(asc.mat)
# Calculate distance matrix
dist.mat = calc_distance_matrix(asc.mat, distance.method = distance)
# --------------------------
# Do projection to 2d space
# --------------------------
# Check for zeros appart of the main diagonal
if (any(rowSums(dist.mat == 0.) > 1)){
warning("Zero dissimilarity between non-identical entries.")
k = ncol(asc.mat)
dist.mat = resolve.nondiag.zeros(dist.mat, k)
}
if (projection == 'iso'){
proj = suppressMessages(isomap_transformation(dist.mat,
isomap.k = isomap.k))
}
if (projection == 'mds'){
#res = mds_transformation(d)
proj = suppressMessages(sammons_tranformation(dist.mat))
}
if (projection == 'cca'){
proj = suppressMessages(cca_transformation(dist.mat,
cca.epochs,
cca.alpha0))
}
if (projection == 'tsne'){
proj = suppressMessages(tsne_transformation(dist.mat,
tsne.perplexity,
tsne.iterations))
}
# Do 2d projection
xy = proj$ProjectedPoints
# Calculate circle radius
layout = create_layout(xy, no.members, scale.factor = scale.factor)
# Circle packing
if (packing){
layout = packing_simple(layout)
} else {
layout = data.frame(layout)
}
# Set  colnames
layout = setNames(layout, c('x', 'y', 'radius'))
# Set rownames
rownames(layout) = rownames(x)
# Calculate number of members
layout$size = no.members
# Calculate importance
layout$importance = -log10(x[,pvalues])
# Set weights
weights = rep(1, nrow(layout))
if (weighted){
weights = layout$importance
}
# Calculate closeness and add to layout
layout$closeness = calc_closeness(dist.mat, weights)
# ---------------------
# Calculate distortion
# ---------------------
# Calculate euclidean distance between instances after projection
dx = as.matrix(suppressMessages(philentropy::distance(layout[,1:2], method = 'euclidean')))
# Calculate Kruskal stress after projection and packing
stress = ProjectionBasedClustering::KruskalStress(dist.mat, dx)
message(paste('Kruskall stress :', sprintf('%1.3f', stress)))
# Calculate spearman correlation
spcorr = cor(c(dist.mat), c(dx), method = 'spearman')
message(paste('Rank correlation :', sprintf('%1.3f', spcorr)))
# -----------------------
# Extended functionality
# -----------------------
# Do clustering
if (clustering){
# Clustering
layout$cluster = hkclustering(dist.mat,
weights,
no.clusters = no.clusters,
max.clusters = max.clusters,
hc.method = hc.method,
cluster.stat = cluster.stat)
# Calculate intracluster weights
layout$intracluster_closeness = intracluster_closeness(layout$cluster,
dist.mat,
weights)
# Add cluster names
layout$cluster = annotate_clusters(layout$cluster,
layout$intracluster_closeness,
rownames(layout))
}
# Return
return(layout)
}
colnames(gsoap_layout(pxgenes, 'Members', 'FDR', scale.factor = 0.5))
library(gsoap)
devtools::document()
devtools::test()
gsoap_layout(pxgenes, 'Members', 'p.value')
devtools::test()
devtools::test()
devtools::test()
devtools::document()
library(gsoap)
devtools::document()
devtools::test()
library(gsoap)
data(pxgenes)
DISTANCE_METHODs = c('jaccard',
'manhattan',
'dice',
'pearson')
PROJECTION_METHODs = c('iso',
'mds',
'cca',
'tsne')
HC_METHODS = c('ward.D',
'ward.D2',
'single',
'average',
'median',
'centroid')
PACKING_OPTIONs = c(TRUE, FALSE)
CLOSENESS_OPTIONs = c(TRUE, FALSE)
CLUSTERING_OPTIONs = c(TRUE, FALSE)
CLUSTER_STATS_OPTIONs = c('meta',
'PBC',
'HGSD',
'ASW',
'ASWw',
'CH',
'R2',
'CHsq',
'R2sq',
'HC')
sample_bool = function(){
sample(c(TRUE, FALSE), 1)
}
N = 100
all_args = list()
for (i in 1:N){
args = list('distance' = sample(DISTANCE_METHODs, 1),
'projection' = sample(PROJECTION_METHODs, 1),
'weighted' = sample_bool(),
'packing' = sample_bool(),
'clustering' = sample_bool(),
'hc.method' = sample(HC_METHODS, 1),
'cluster.stat' = sample(CLUSTER_STATS_OPTIONs, 1, prob = c(10, rep(1, 9))))
color = ifelse(args[['clustering']],
'cluster',
ifelse(args[['closeness']],
'closeness',
'importance'))
alpha = ifelse(args[['clustering']],
'intracluster_closeness',
'importance')
viridis = sample(c('viridis', 'magma', 'plasma', 'inferno', 'cividis'), 1)
args[['color']] = color
args[['alpha']] = alpha
args[['viridis']] = viridis
args[['which.labels']] = sample(nrow(pxgenes), 5)
all_args[[i]] = args
}
pdf('./img/exhtest.pdf')
for (i in 1:N){
args = all_args[[i]]
print(i)
print(args)
l = gsoap_layout(pxgenes,
'Members',
'p.value',
distance = args$distance,
projection = args$projection,
weighted = args$weighted,
log10.weights = args$log10.weights,
packing = args$packing,
closeness = args$closeness,
clustering = args$clustering,
hc.method = args$hc.method,
cluster.stat = args$cluster.stat)
l$p.value = -log10(pxgenes$p.value)
print(head(l))
p = gsoap_plot(l,
as.color = args$color,
as.alpha = args$alpha,
show.size.guide = sample_bool(),
show.color.guide = sample_bool(),
show.alpha.guide = sample_bool(),
viridis.option = args$viridis,
which.labels = args$which.labels)
plot(p)
}
dev.off()
library(gsoap)
data(pxgenes)
DISTANCE_METHODs = c('jaccard',
'manhattan',
'dice',
'pearson')
PROJECTION_METHODs = c('iso',
'mds',
'cca',
'tsne')
HC_METHODS = c('ward.D',
'ward.D2',
'single',
'average',
'median',
'centroid')
PACKING_OPTIONs = c(TRUE, FALSE)
CLOSENESS_OPTIONs = c(TRUE, FALSE)
CLUSTERING_OPTIONs = c(TRUE, FALSE)
CLUSTER_STATS_OPTIONs = c('meta',
'PBC',
'HGSD',
'ASW',
'ASWw',
'CH',
'R2',
'CHsq',
'R2sq',
'HC')
sample_bool = function(){
sample(c(TRUE, FALSE), 1)
}
N = 100
all_args = list()
for (i in 1:N){
args = list('distance' = sample(DISTANCE_METHODs, 1),
'projection' = sample(PROJECTION_METHODs, 1),
'weighted' = sample_bool(),
'packing' = sample_bool(),
'clustering' = sample_bool(),
'hc.method' = sample(HC_METHODS, 1),
'cluster.stat' = sample(CLUSTER_STATS_OPTIONs, 1, prob = c(10, rep(1, 9))))
color = ifelse(args[['clustering']],
'cluster',
ifelse(args[['closeness']],
'closeness',
'importance'))
alpha = ifelse(args[['clustering']],
'intracluster_closeness',
'importance')
viridis = sample(c('viridis', 'magma', 'plasma', 'inferno', 'cividis'), 1)
args[['color']] = color
args[['alpha']] = alpha
args[['viridis']] = viridis
args[['which.labels']] = sample(nrow(pxgenes), 5)
all_args[[i]] = args
}
pdf('./img/exhtest.pdf')
for (i in 1:N){
args = all_args[[i]]
print(i)
print(args)
l = gsoap_layout(pxgenes,
'Members',
'p.value',
distance = args$distance,
projection = args$projection,
weighted = args$weighted,
packing = args$packing,
clustering = args$clustering,
hc.method = args$hc.method,
cluster.stat = args$cluster.stat)
l$p.value = -log10(pxgenes$p.value)
print(head(l))
p = gsoap_plot(l,
as.color = args$color,
as.alpha = args$alpha,
show.size.guide = sample_bool(),
show.color.guide = sample_bool(),
show.alpha.guide = sample_bool(),
viridis.option = args$viridis,
which.labels = args$which.labels)
plot(p)
}
dev.off()
library(gsoap)
data(pxgenes)
DISTANCE_METHODs = c('jaccard',
'manhattan',
'dice',
'pearson')
PROJECTION_METHODs = c('iso',
'mds',
'cca',
'tsne')
HC_METHODS = c('ward.D',
'ward.D2',
'single',
'average',
'median',
'centroid')
PACKING_OPTIONs = c(TRUE, FALSE)
CLOSENESS_OPTIONs = c(TRUE, FALSE)
CLUSTERING_OPTIONs = c(TRUE, FALSE)
CLUSTER_STATS_OPTIONs = c('meta',
'PBC',
'HGSD',
'ASW',
'ASWw',
'CH',
'R2',
'CHsq',
'R2sq',
'HC')
sample_bool = function(){
sample(c(TRUE, FALSE), 1)
}
N = 100
all_args = list()
for (i in 1:N){
args = list('distance' = sample(DISTANCE_METHODs, 1),
'projection' = sample(PROJECTION_METHODs, 1),
'weighted' = sample_bool(),
'packing' = sample_bool(),
'clustering' = sample_bool(),
'hc.method' = sample(HC_METHODS, 1),
'cluster.stat' = sample(CLUSTER_STATS_OPTIONs, 1, prob = c(10, rep(1, 9))))
color = ifelse(args[['clustering']],
'cluster',
sample(c('closeness', 'importance'), 1))
alpha = ifelse(args[['clustering']],
'intracluster_closeness',
'importance')
viridis = sample(c('viridis', 'magma', 'plasma', 'inferno', 'cividis'), 1)
args[['color']] = color
args[['alpha']] = alpha
args[['viridis']] = viridis
args[['which.labels']] = sample(nrow(pxgenes), 5)
all_args[[i]] = args
}
pdf('./img/exhtest.pdf')
for (i in 1:N){
args = all_args[[i]]
print(i)
print(args)
l = gsoap_layout(pxgenes,
'Members',
'p.value',
distance = args$distance,
projection = args$projection,
weighted = args$weighted,
packing = args$packing,
clustering = args$clustering,
hc.method = args$hc.method,
cluster.stat = args$cluster.stat)
l$p.value = -log10(pxgenes$p.value)
print(head(l))
p = gsoap_plot(l,
as.color = args$color,
as.alpha = args$alpha,
show.size.guide = sample_bool(),
show.color.guide = sample_bool(),
show.alpha.guide = sample_bool(),
viridis.option = args$viridis,
which.labels = args$which.labels)
plot(p)
}
dev.off()
library(gsoap)
devtools::document()
devtools::test()
?cca_tranformation
library(philentropy)
?cca_tranformation
library(ProjectionBasedClustering)
?cca_tranformation
?CCA
library(gsoap)
devtools::document()
devtools::test()
?gsoap_plot
library(gsoap)
devtools::test()
devtools::document()
?data
# Load GSOAP package
library(gsoap)
# Load example dataset
data(pxgenes)
# Create GSOAP layout
layout = gsoap_layout(pxgenes, 'Members', 'p.value')
# Order instances by their significance
layout = layout[order(layout$significance),]
# Create GSOAP plot
gsoap_plot(layout, as.color = 'cluster', as.alpha = 'significance', which.label = 1:5)
library(gsoap)
# Load GSOAP package
library(gsoap)
# Load example dataset
data(pxgenes)
# Create GSOAP layout
layout = gsoap_layout(pxgenes, 'Members', 'p.value')
# Order instances by their significance
layout = layout[order(layout$significance),]
# Create GSOAP plot
gsoap_plot(layout, as.color = 'cluster', as.alpha = 'significance', which.label = 1:5)
colnames(layout)
